## 첫 스터디 진행 절차는 야심차게(?) 아래와 같이 준비함

1. icebreaking: 편하게 간단한 자기소개
    - “나는 왜 취업이 절실한가” 한번 고민해보고 와서 공유해주시면 좋습니다
      
2. diagnostic test: 자기 스스로 상태(?) 점검용 모의 면접
    - 진짜 면접 대비하기 위함이 아니라, “내가 진짜 빡세게 준비해야겠구나” 느끼고 동기부여하기 위함입니다  
    - 안드로이드/코틀린 관련 예상 면접 질문 최소 5~10개 텍스트로 준비해주세요  
        - 내가 면접관이라고 생각하고, 핵심적인 주제/지엽적인 주제, 난이도 하/상 고려해서 선별해주시면 좋습니다
        - 자바와의 비교나 CS 지식이 포함된 질문도 OK (저도 잘 모르지만 실제 면접에 충분히 나올 수 있음)
        - 내가 완벽하게 답할 수는 없어도 대충이라도 답할 수 있게 아는 내용 위주로 해주세요 (이번에 찾아보고 공부해서 새롭게 알게 된 내용도 Good)
        - 개수가 많다고 생각할 수 있지만 겹칠 가능성 고려해서 정했고, 이상 목표치니 너무 부담 갖지 마세요
    - 진행 방식은, 한 명씩 교대로 질문 공유하고, 공유자 외 나머지 팀원들이 교대로 답변 시도(?)하고 아예 모르는 주제면 패스하면 됩니다~  
      
3. diagnostic test review: 모의 면접 복기 및 리뷰
    - 질문별로 하나씩 리뷰하면서, 답변 내용 중에 틀린 부분 있으면 서로 고쳐주고 잘한 부분 있으면 칭찬해주면 됩니다  
    - 모의 면접을 쭉 진행한 다음, 리뷰를 할까 하는데 병렬 진행도 괜찮구요
      
4. plan:  추후 안드로이드/코틀린 스터디 주제 토의 및 선정
   
6. plan ii: 자바, CS, 코테 등 기타 주제 관련 토의 및 선정

> 내가 시간 관리에 소홀한 바람에 모의 면접과 리뷰만 진행하고, 다음 스터디 주제를 의논할 시간이 없었음  
> 급한 대로 Compose + 코틀린 함수로 결정!

## 모의 면접 질문 리스트

- <img src="jungkeun.png" alt="jungkeun" width="24"/> 정근: Scope Function이 무엇이 있는지 간단히 설명해주시고, 프로젝트에 어떻게 활용했는지 소개해주세요

- <img src="heepyo.png" alt="heepyo" width="24"/> 희표: Abstract Class와 Interface의 차이를 설명해주세요.

- <img src="seungmin.png" alt="seungmin" width="24"/> 승민: 안드로이드 4대 컴포넌트에 대해 설명해주세요.

- <img src="gunhee.png" alt="gunhee" width="24"/> 건희: 변수 생성시 val var 키워드 차이점

- <img src="hyewoon.png" alt="hyewoon" width="24"/> 혜운: 액티비티 생명주기는?

- <img src="gunhee.png" alt="gunhee" width="24"/> 건희: 큐와 스택의 차이

- <img src="hyewoon.png" alt="hyewoon" width="24"/> 혜운: 코틀린에서 ?, !! 의미는? 코루틴과 스레드의 차이?

- <img src="jungkeun.png" alt="jungkeun" width="24"/> 정근: 멀티스레드 환경의 동시성 문제를 설명해주시고, MutableStateFlow가 어떻게 이 문제에 대응해 Thread-safe한지 설명해주세요

> 마지막에 수소폭탄급 고난도 질문을 투척해버림;;

## 복기

### Abstract Class VS Interface

갑자기 차이를 설명하려니 헷갈림  
현재 플젝에서 활용 사례를 떠올리면, 메서드 하나를 여러 프래그먼트에서 노나 쓸라고 만든 일종의 BaseFragment 추상 클래스가 있음  
(프로필 이미지를 preload해서 캐싱하는 메서드가 그 주인공)  
그래서 이름은 추상인데, 프로퍼티와 메서드 둘 다 추상, 구체 모두 허용됨  
특이사항은, abstract 키워드가 inheritance modifier로서 open의 의미를 포괄하기 때문에 클래스 자체의 상속은 허용되지만, 개별 멤버들은 open 없이 상속 불가  
그리고 abstract class는 interface와 달리 생성자를 가질 수 있음!

한편, 인터페이스의 활용 사례로는, 레트로핏 인스턴스를 생성해 반환하는 Service 인터페이스가 있"었"음  
(왜 과거형이냐면, 힐트 도입 후 HiltModule에 잡아먹혀(?)버렸기 때문)  
그때 기억을 더듬어보면, 인터페이스 역시 희한하게도(?) 구체 메서드가 허용됨  
단, 프로퍼티의 경우, (지금 테스트해본 결과) property initializer는 허용 안 되고, getter는 허용됨  
-> 이렇게 설계된 배경은 다음 시간에 공부하기로..

-- To be continued..
