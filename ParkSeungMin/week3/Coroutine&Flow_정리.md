# 안드로이드 3주차 정리 Coroutine/Flow


## 1. Coroutine이란?
코루틴이란 스레드에서 실행되는 비동기 코드 조각이다. 하나의 스레드에 여러 코루틴을 할당하고, 이 코루틴들을 적절하게 중지시키고 재게하여 프로그램이 실행된다.

즉, 코루틴은 **중단**했다가, 다시 실행할 수 있는 컴포넌트이다.

여기서 중단한다는 개념이 중요하다. 코루틴을 중단시켰을 때 코루틴이 배정된 스레드는 블로킹되지 않는다. 다만 해당 코루틴을 중단시키고, 다른 코루틴을 실행시킨다.

그렇다면 기존의 스레드 전환 방식 사용했을 때 발생할 수 있는 문제점은?
- 스레드가 실행되었을 때 멈출 수 있는 방법이 없어 메모리 누수로 이어질 수 있다.
- 스레드는 생성과 컨텍스트 스위칭 비용이 비싸다.
- 스레드를 자주 전환하면, 복잡도가 증가하고, 관리하기 어려운 문제가 있다.

![](https://velog.velcdn.com/images%2Fhaero_kim%2Fpost%2F96cd2cfd-4539-4417-9f13-ab905446e0e2%2Fno-context-switch-between-coroutines.png)

![출처: https://blog.kakaocdn.net/dn/EYDUU/btrKHvVifaa/nNll0j0djzRj8veTGmSs3K/img.gif](https://blog.kakaocdn.net/dn/EYDUU/btrKHvVifaa/nNll0j0djzRj8veTGmSs3K/img.gif)
## 2. 코루틴 빌더란?
모든 중단 함수는 다른 중단 함수에 의해 실행되어야 하며, 앞에서 호출한 중단 함수 또한 마찬가지이다. 중단함수가 연속적으로 호출될 때 그 시작점이 반드시 존재하는데, 코루틴을 만들고 실행하는 **코루틴 빌더** 함수가 그 역할을 한다.

대표적인 코루틴 빌더 함수는 다음과 같다.
- **launch 빌더**
  launch 빌더는 가장 기본적인 형태의 코루틴 빌더로, 비동기적으로 작업을 실행할 때 사용된다.
  반환값이 없고, 코루틴이 실행되면 즉시 제어를 반환한다.
- **async 빌더**
  async 빌더는 코루틴으로 비동기 작업을 실행하고 결과를 반환하는 데 사용된다. Deferred 인스턴스를 반환하며, 결과를 얻기 위해선 `await()`메서드를 사용합니다.
- **runBlocking 빌더**
  RunBlockng 빌더는 위두 빌더와는 다른 조금 특별한 코루틴 빌더이다.
  코루틴이 실행한 뒤 완료될 때까지 현재 스레드를 중단 가능한 상태로 블로킹한다. 주로 테스트나 프로그램이 끝나는 것을 방지하기 위해 스레드를 블로킹 할 필요가 있는 경우 사용했지만, 현재는 잘 쓰이지 않고 있다.

`launch`와 `async` 빌더는 **CorounieScope** 인터페이스의 확장 함수이다.
CoroutineScope 인터페이스는 부모 코루틴과 자식 코루틴 사이의 관계를 정립하기 위한 목적으로 사용되는 **구조화된 동시성**의 핵심 개념이다.

모든 코루틴은 코루틴 스코프 내에서 빌더를 호출함으로써 시작된다는 것을 기억하자.



## 3. 구조화된 동시성이란?
부모 코루틴은 자식 코루틴을 위해 스코프를 제공하고, 자식들은 해당 스코프 내에서 호출 한다.
이를 통해 **구조화된 동시성**이라는 관계가 성립한다.

다음은 부모-자식 코루틴 사이의 중요한 특징이다.
- 자식은 부모로부터 컨텍스트를 상속받는다.
- 부모는 모든 자식이 작업을 마칠 때까지 기다린다.
- 부모 코루틴이 취소되면 자식 코루틴도 취소된다.
- 자식 코루틴에서 예외가 발생하면 부모 코루틴 또한 예외가 전달된다.


## 4. Job이란?

**Job**은 Kotlin Coroutine을 컨트롤하기 위한 것이다. Job을 통해서 하나 혹은 여러개의 coroutine을 제어할 수 있다.

-   Job은 코루틴의 생명주기와 관련된 핵심 개체이다. 코루틴의 실행, 취소, 완료 등을 추적할 수 있다.
-   모든 코루틴은 기본적으로 하나의 Job과 연관이 된다. 이Job은 코루틴이 실행될 때 생성되며, 코루틴이 완료되거나 취소될 때 제거가 된다.
-   Job은 코루틴이 완료되었는지 또는 취소되었는지 확인할 수 있도록 여러 메서드와 속성을 제공한다.  또한 부모-자식 관계를 통해 코루틴 간의 관계를 추적한다.

![](https://user-images.githubusercontent.com/57784077/176878164-6c7b99e2-99d9-48e7-be94-8f379a062857.png)
- **New**: 지연 시작되는 코루틴은 New에서부터 생명주기가 시작된다.
- **Active**: 지연시작이 아닌 대부분의 코루틴은 Activite 상태로 시작이 된다.
- **Compliting**: 코루틴 실행이 완료되면 Compliting 상태가 된다. 이 때 Completed가 아닌 이유는 자식들의 코루틴 실행 종료를 기다리는 것이다.
- **Completed**: 자식들의 코루틴 실행도 마쳤다면 마지막 상태인 Completed가 된다.
- **Cancelling**: 만약 잡이 실행 도중에 취소되거나 실패하면, Cancelling 상태가 된다. 이 상태에서 연결을 끊거나, 자원을 반납하는 등의 후처리 작업을 할 수 있다.
- **Cancelled**: 후처리 작업이 모두 완료되면 Cancelled 상태가 된다.

Job을 통해서 현재 코루틴의 상태를 추적할 수 있으며, 코루틴의 취소와 예외, 완료에 대한 제어를 할 수 있다.
또한 부모-자식 관계를 제공하여, 부모 코루틴의 Job을 기반으로, 자식 코루틴의 Job이 생성된다.

Job은 일반적으로 명시적으로 생성되지 않고, `launch`나 `async`와 같은 빌더에 의해 자동으로 생성된다. 필요에 따라 Job을 직접 만들고 조작할 수 있어, 코루틴의 생명 주기를 세밀히 제어할 수 있는 장점이 있다.


## 5. 중단함수란?
중단함수는 함수 내에서 일시 중단할 수 있는 함수를 가지는 특별한 함수이다.
코루틴은 언제든지 자신을 일시 중단하고, 다른 코루틴에게 스레드를 양보할 수 있다는 점이 중요하다.
중단함수는 일시 중단할 수 있는 코루틴들로 이루어진 함수라고 볼 수도있다.

중요한 점은 중단 함수는 코루틴이 아니라는 것이다. 새로운 코루틴의 흐름을 만들고 싶다면 코루틴 빌더를 사용해야 한다.
```kotlin
fun main() = runBlocking {
	delayOneSec()
	delayOneSec()
	delayOneSec()

	//실행시간: 3초 걸림
}
suspend fun delayOneSec() {
	delay(1000)
}
```

```kotlin
fun main() = runBlocking {
	GlobalScope.launch {
		delayOneSec()
	}
	GlobalScope.launch {
		delayOneSec()
	}
	GlobalScope.launch {
		delayOneSec()
	}
	//실행시간: 1.~~ 초 걸림
}
suspend fun delayOneSec() {
	delay(1000)
}
```
중단 함수는 다른 **중단 함수** 또는 **코루틴 스코프** 내에서만 호출된다는 것 또한 기억하자.

## 6. 코루틴 디스패처란?
모든 코루틴은 스레드 위에서 동작해야 한다. 이 때 코루틴이 어느 스레드에서 동작할지 결정하는 것이 코루틴 디스패처이다.

즉, 코루틴을 만들면, 코루틴 디스패처는 자신이 사용할 수 있는 스레드 풀의 스레드 중 하나를 골라 코루틴을 해당 스레드에 보낸다.

### 코루틴 디스패처의 종류

- **기본 디스패처(Dispatchers.Default)**
  디스패처를 설정하지 않으면 기본적으로 설정되는 디스패처이다.
  CPU 집약적인 연산을 수행하도록 설계되어 있다.

- **메인 디스패처(Dispatchers.Main)**
  안드로이드에서 메인 스레드는 UI와 상호작용하는 유일한 스레드이다.
  안드로이드에서 UI 업데이트나 이벤트 처리 등 UI 관련 작업을 수행할 때 사용된다.

- **IO 디스패처(Dispatchers.IO)**
  네트워크나 디스크 입출력 작업을 수행할 때 사용된다.
  디스크나 네트워크 I/O가 필요한 비동기 작업을 수행할 때 적한한 디스패처이다.
  즉, I/O 연산으로 스레드를 블로킹할 때 사용하기 위해 설계되었다.
  이 디스패처는 백그라운드 I/O 스레드 풀을 사용한다


## 7. Flow란?
플로우는 비동기적으로 계산해야 할 값의 스트림을 나타내며, 코루틴 상에서 리액티브 프로그래밍을 지원하기 위한 구성요소이다.
즉, 단일 값만 반환하는 중단 함수와 달리 여러 값을 순차적으로 내보낼 수 있는 유형이다.

![](https://developer.android.com/static/images/kotlin/flow/flow-entities.png?hl=ko)

-   **생산자**는 스트림에 추가되는 데이터를 생산한다. 코루틴 덕분에 흐름에서 비동기적으로 데이터가 생산될 수도 있다.
-   **(선택사항) 중개자**는 스트림에 내보내는 각각의 값이나 스트림 자체를 수정할 수 있다.
-   **소비자**는 스트림의 값을 수집하고 사용한다.

`flow` 빌더 함수는 `emit` 함수를 사용하여 새 값을 수동으로 데이터 스트림에 내보낼 수 있는 새 Flow를 만든다.

그리고 소비자는 `collect`를 통해 데이터 Flow를 받을 수 있다.

`flow` 빌더는 코루틴 내에서 실행된다. 따라서 동일한 비동기 API의 이점을 활용할 수 있지만 몇 가지 제한사항이 존재한다.

-   Flow는 순차적이다. 생산자가 코루틴에 있으므로, 중단 함수를 호출하면 생산자는 중단 함수가 반환될 때까지 중단 상태로 유지된다.
-   `flow` 빌더에서는 생산자가 다른 `CoroutineContext`의 값을 `emit`할 수 없다. 그러므로 새 코루틴을 만들거나 코드의 `withContext` 블록을 사용하여 다른 `CoroutineContext`에서 `emit`을 호출해서는 안된다.
    이런 경에는 `callbackFlow`와 같은 다른 흐름 빌더를 사용해서 처리할 수 있다.

### 그렇다면 Flow는 언제 사용해야 할까?

**Flow를 실제 사용 예**
- 웹 소켓과 같이 서버가 보낸 이벤트를 통해 전달된 메시지를 받게 되는 경우
- 텍스트 입력, 혹은 클릭과 같이 사용자 액션이 감지되는 경우
- 센서 또는 GPS와 같은 기기의 정보 변경을 받는 경우
- DB의 변경을 감지하는 경우

Retrofit을 이용한 HTTP 통신을 하는 경우와 같이 단일 값을 받는 경우에는 중단 함수를 사용하자.(필수는 아님)

**또한 Flow를 반환하는 함수가 중단함수가 되어서는 안되는다는 것을 기억하자.**

Flow는 `collect` 함수를 통해 시작되는 특정 프로세스를 나타낸다.
Flow를 반환하는 함수가 프로세스를 정의하게 되며, 프로세스가 시작될 때까지, 프로세스를 실행하지 않는다.

반면, **중단함수**는 프로세스를 직접 수행하기 때문에 두 개념은 서로 혼용해서 사용하는 것은 직관적이지 않으면 문제를 일으킬 수 있다.
