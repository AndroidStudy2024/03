## 객체지향 프로그래밍에 대하여
객체 지향 프로그래밍이란, 시스템을 상호작용하는 **자율적인 객체**들의 공동체로 바라보고, 객체를 이용해 시스템을 분할하는 방법을 말한다.

여기서 자율적인 객체란, **상태**와 **행위**를 가지며, 스스로 자기 자신을 책임지는 객체를 의미한다.

객체는 원하는 행위를 구현하기 위해 다른 객체들과 **협력**해야 한다. 각 객체는 협력 내에서 정해진 **역할**을 수행한다. 여기서 역할이란, 관련된 **책임의 집합**을 의미한다.

객체들 사이 상호작용을 위해 **메시지**를 전송해야 한다. 그리고 메시지를 받는 객체는 메시지를 처리하기 위해 적절한 **메소드**를 자율적으로 선택해야 한다.

즉 정리하면, 객체 지향 프로그래밍이란, 여러 객체들이 모여 서로 상호 협력을 통해 로직을 구성해나가는 프로그래밍 방법을 뜻한다.


## 객체지향 프로그래밍의 4가지 특징
객체지향 프로그래밍의 4가지 중요한 특징으로는 추상화, 상속, 다형성, 캡슐화가 있다.

### 추상화
> 추상화란 어떤 양상, 세부 사항, 구조를 조금 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
복잡도를 극복하기 위해 두가지 차원에서 이루어진다.
- 구체적인 사물들 간의 공통점은 취하고, 차이점은 버리는 **일반화**를 통해 단순하게 만드는 것이다. - 데이터 추상화
- 중요한 부분을 강조하기 위해 **불필요한 세부 사항을 제거**함으로써 단순하게 만드는 것이다. - 제어 추상화

간단하게 추상화란, **원하는 특성만 취하고 필요 없는 부분을 추려 핵심만 표현하는 행위를 뜻한다.**

### 상속
상속은 기존 클래스(부모 클래스)의 속성과 메서드를 다른 클래스(자식 클래스)가 재사용하는 메커니즘이다.
하지만, 모든 멤버를 상속받더라도 항상 직접적으로 접근할 수 있는 것은 아니다.
접근 제어자가 `private`인 경우에는 자식 클래스는 부모 클래스의 해당 메소드 혹은 멤버에 직접적으로 접근할 수 없다.

### 다형성
다형성이란 같은 자료형에 여러가지 타입의 데이터를 대입하여 다양한 결과를 얻어낼 수 있는 성질을 의미한다.

대표적으로, 오버로딩, 오버라이딩, 업캐스팅, 다운캐스팅, 인터페이스, 추상 메소드, 추상 클래스 등이 모두 다형성에 속한다.

그렇다면 다형성을 통해 얻을 수 있는 장점은 무엇이 있을까?

먼저, **타입을 묶을 수 있다는 것**이다.
서로 다른 하위 객체들을 하나의 수퍼 타입으로 묶어 List와 같이 하나로 묶을 수 있는 장점이 있다.

그리고 다른 장점으로는, 동일한 메시지에 대해 **객체에 따라서 다른 방식으로 처리할 수 있다.**
이는 타입을 묶었을 때의 장점과 이어지는데, 하나의 상위 타입으로 객체들을 묶었을 때, 오버라이딩 등을 통해 각각의 객체가 수행해야 하는 구체적인 행동들을 구현할 수 있다.

즉 외부에서는 해당 객체가 어떻게 동작하는지는 알 필요가 없다. 단지, 어떤 동작을 하라고 메시지를 전달할 뿐이다. 메시지를 받은 객체는 내부에서 자율적으로, 해당 동작을 구현해야 한다.  
이 내용들은 캡슐화와도 관련이 있는 것 같다.


### 캡슐화
캡슐화란 클래스 내 변수나 메소드들을 캡슐로 감싸서 안보이게 하는 **정보 은닉** 개념 중 하나이다.

먼저 객체의 행동은 크게 **공용 인터페이스**와 **구현** 2가지로 나뉜다.

- 공용 인터페이스는 외부에서 접근 가능한 객체의 행동들의 집합을 뜻한다..
- 구현은 외부에서 접근이 불가능하고 오직 내부에서만 접근 가능한 부분을 의미한다.

외부에 제공해야 할 필요가 있는 메시지만을 객체의 공용 인터페이스에 포함시키고, 객체가 수행해야 하는 구체적인 행동은 공용 인터페이스의 뒤에 감춤으로써 외부의 간섭으로부터 내부 상태를 격리시킬 수 있다.

즉, 공용 인터페이스를 수정하지 않는 한 자신과 협력하는 외부 객체에 영향을 미치지 않고 내부의 구현을 자유롭게 수정할 수 있다.





## SOLID 원칙이란?

### Single Responsibility Principle - 단일 책임 원칙
클래스는 단 **하나의 책임**을 가진다는 원칙이다.
즉, 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하도록, 클래스를 따로 따로 여러 개 설계하라는 원칙이다.

하나의 모듈이 변경될 때는 하나의 이유에만 변경되어야 한다. 만약 하나의 모듈이 여러 책임을 가지게 된다면, 책임을 요청하는 객체가 변경될 때, 여러번 변경되게 된다.
그렇기 때문에 만약 하나의 모듈이 하나의 책임을 가지고 있다면, 변경되는 이유 또한 하나일 것이다.

### Open Closed Principle - 개방 폐쇄 원칙

확장에는 열려 있어야 하며, 수정에는 닫혀 있어야 한다는 원칙이다.

여기서
**확장에 대해 열려 있다:** 요구 사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
**수정에 대해 닫혀 있다:** 기존의 코드를 수정하지 않고 애플리에케이션의 동작을 추가하거나 변경할 수 있다.

어렵게 생각할 것 없이, 추가 기능은 쉽게 추가할 수 있고, 요구사항의 변화에 대해서는 코드 수정을 최소화하도록 하자는 의미인 것 같다.

위에 작성한 **추상화**와 **캡슐화**를 통해 이룰 수 있을 것이다.
공용 인터페이스와 구현부를 분리하고, 객체를 추상화 함으로써, 코드 수정을 최소화하고, 기능 추가를 손쉽게 할 수 있을 것 같다.


### Liskov Substitution Principle - 리스코프 치환 원칙
리스코프 치환 원칙은 **하위 타입은 상위 타입을 대체**할 수 있어햐 하는 것을 의미한다.

즉, LSP는 다형성을 위한 원칙이라 볼 수 있다.
**상위 클래스 타입**으로 객체를 선언하여 **하위 클래스의 인턴턴스**를 받으면, 업캐스팅된 상태에서 부모의 메소드를 사용해도 의도한대로 진행되도록 구성하면 되는 것이다.

클래스를 설계할 때, 잘못된 상속 관계를 구성하게 되거나, 하위 클래스에서 의도하지 않은 메소드를 재정의하게 된다면 LSP를 어길 수 있으므로 조심하자.


### Interface Segregation Principle - 인터페이스 분리 원칙
인터페이스를 각각 사용에 맞게끔 분리하는 것을 의미한다.

인터페이스는 객체가 수행해야 할 관련성 높은 책임들의 집합이다. 하나의 인터페이스에 너무 많은 책임들이 모여 있다면, 외부의 변경으로 인해 많은 수정을 해야 할 것이다. 혹은, 하나의 인터페이스를 구현하는 여러 하위 객체들 중, 어떤 추상 메소드는 구현을 해서는 안되는 경우도 있을 것이다.

예를 들어, `Bird` 인터페이스의 여러 메소드들 중 `fly`라른 메소드가 있을 때, `Bird`를 구현하는 `Penguin` 객체는 이 메소드를 구현해서는 안될 것이다.

그러므로 적절히 인터페이스를 나누고 이 인터페이스들을 필요에 맞는 객체에게 구현하도록 해야 한다.



### Dependency Inversion Principle - 의존성 역전 원칙
어떤 객체를 참조해서 사용해야 하는 상황이 생긴다면, 그 클래스를 직접 참조하는 것이 아닌, 대상의 상위 요소(추상 클래스 혹은 인터페이스)로 참조하는 원칙이다.

즉, 구현 클래스에 의존하는 것이 아닌, 인터페이스에 의존하라는 의미이다.
DIP는 각 클래스 간의 결합도를 낮추는 것을 목표로 한다.

![](https://res.cloudinary.com/practicaldev/image/fetch/s--75l_rRtb--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/zfy3ksx5f6u3u52aw0lm.jpeg)
이런 구조에서 다음 구조로 변경하자.

![](https://res.cloudinary.com/practicaldev/image/fetch/s--e6uxFkyR--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/56xle6db4bhlr5hdonqz.jpeg)

이런 식으로 클래스 구조를 변경하면, 저수준 모듈에서의 기능 추가도 쉽게 가능해질 것이고, 수정을 할 때에도 해당 모듈의 기능에서만 수정 하면 되므로, 외부의 코드에 영향을 주지 않고, 최소한으로 수정할 수 있을 것이다.
작성하고 보니, OCP 원칙과 유사한 모습이 있는 것 같다.

---
### 출처
#### 서적: 객체지향의 사실과 오해
#### 블로그: [인파 티스토리: 객체-지향-설계의-5가지-원칙-SOLID](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)
